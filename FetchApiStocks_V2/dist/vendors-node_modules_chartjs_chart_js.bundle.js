"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkneo_api_stocks"] = self["webpackChunkneo_api_stocks"] || []).push([["vendors-node_modules_chartjs_chart_js"],{

/***/ "./node_modules/chartjs/chart.js":
/*!***************************************!*\
  !*** ./node_modules/chartjs/chart.js ***!
  \***************************************/
/***/ ((module) => {

eval("/*global module:true*/\n\n\nMath.log2 = Math.log2 || function(x) {\n  return Math.log(x) / Math.LN2;\n};\n\nMath.log10 = Math.log10 || function(x) {\n  return Math.log(x) / Math.LN10;\n};\n\n(function() {\n  var Helpers = {\n    avg: function(arr) {\n      var v = 0;\n      for (var index = 0; index < arr.length; ++index) {\n        v += arr[index];\n      }\n      return v / arr.length;\n    },\n    min: function(arr) {\n      if (arr.length === 0) return 0;\n      var v = arr[0];\n      for (var index = 1; index < arr.length; ++index) {\n        var v2 = arr[index];\n        if (Array.isArray(v2)) v2 = Helpers.avg(v2);\n        if (v2 < v) v = v2;\n      }\n      return Math.max(0, v);\n    },\n    max: function(arr) {\n      var v = 0;\n      for (var index = 0; index < arr.length; ++index) {\n        var v2 = arr[index];\n        if (Array.isArray(v2)) v2 = Helpers.avg(v2);\n        if (v2 > v) v = v2;\n      }\n      return Math.max(0, v);\n    },\n    upperMax: function(arr) {\n      var v = 0;\n      for (var index = 0; index < arr.length; ++index) {\n        var v2 = arr[index];\n        if (Array.isArray(v2)) v2 = Helpers.max(v2);\n        if (v2 > v) v = v2;\n      }\n      return Math.max(0, v);\n    },\n    lowerMin: function(arr) {\n      if (arr.length === 0) return 0;\n      var v = arr[0] || Infinity;\n      if (Array.isArray(v)) v = Helpers.lowerMin(v);\n      for (var index = 1; index < arr.length; ++index) {\n        var v2 = arr[index];\n        if (v2 == null) continue;\n        if (Array.isArray(v2)) v2 = Helpers.lowerMin(v2);\n        if (v2 < v) v = v2;\n      }\n      if (isNaN(v) || !isFinite(v)) v = 0;\n      return Math.max(0, v);\n    },\n    niceNumbers: function(range, round) {\n      var exponent = Math.floor(Math.log10(range));\n      var fraction = range / Math.pow(10, exponent);\n      var niceFraction;\n      if (round) {\n        if (fraction < 1.5) niceFraction = 1;\n        else if (fraction < 3) niceFraction = 2;\n        else if (fraction < 7) niceFraction = 5;\n        else niceFraction = 10;\n      } else {\n        if (fraction <= 1.0) niceFraction = 1;\n        else if (fraction <= 2) niceFraction = 2;\n        else if (fraction <= 5) niceFraction = 5;\n        else niceFraction = 10;\n      }\n      return niceFraction * Math.pow(10, exponent);\n    },\n    getLinearTicks: function(min, max, maxTicks) {\n      var range = Helpers.niceNumbers(max - min, false);\n      var tickSpacing = Helpers.niceNumbers(range / (maxTicks - 1), true);\n      return [\n        Math.floor(min / tickSpacing) * tickSpacing,\n        Math.ceil(max / tickSpacing) * tickSpacing,\n        tickSpacing\n      ];\n    },\n    getFont: function(options) {\n      options.style = options.style || 'normal';\n      options.variant = options.variant || 'normal';\n      options.weight = options.weight || 'lighter';\n      options.size = options.size || '12';\n      options.family = options.family || 'Arial';\n      return [options.style, options.variant, options.weight, options.size + 'px', options.family].join(' ');\n    },\n    getAxisRatio: function(min, max, value) {\n      return (value - min) / (max - min);\n    }\n  };\n\n  var BarChart = (function() {\n    function BarChart(ctx, options) {\n      this.mouseListeners = [];\n      this.currentHint = null;\n      this.fillRegions = []\n      this.options = {\n        font: 'Helvetica',\n        fontWeight: 'normal',\n        fontSizeTitle: 24,\n        fontSizeAxes: 20,\n        fontSizeTicks: 18,\n        fontSizeLabels: 18,\n        fontDataTags: 18,\n        fontSizeLegend: 18,\n        fontSizeHint: 18,\n        paddingPercentBars: 0.10,\n        paddingPercentTicks: 0.15,\n        paddingPixelsVertical: 10,\n        paddingPixelsHorizontal: 10,\n        paddingPixelsTicks: 10,\n        maxWidthBars: 0,\n        fillColorBackground: 'rgb(255, 255, 255)',\n        strokeColorBars: 'rgb(0, 0, 0)',\n        fillColorBars: 'rgba(180, 180, 180, 0.25)',\n        scaleStyle: 'linear',\n        barStyle: 'none',\n        stackedBarPadding: 3,\n        defaultMaxTick: 0,\n        pixelsLegendSquare: 10,\n        radiusDot: 5,\n        fillColorLegend: 'rgb(230, 230, 230)',\n        tickFormatter: null,\n        tickFormatterMeasure: null,\n        fillRegion: 'normal'\n      };\n      options = options || { };\n      for (var key in this.options) {\n        if (options.hasOwnProperty(key)) this.options[key] = options[key];\n      }\n      this.ctx = ctx;\n      this.content = { };\n      this.labelPositions = { }\n    }\n\n    BarChart.prototype.update = function(content) {\n      if (typeof content !== 'object') {\n        throw new Error('Collections must be objects.');\n      } else if (!(content.hasOwnProperty('labels') && content.hasOwnProperty('data'))) {\n        throw new Error('Collection must specify labels and data.');\n      } else if (!(Array.isArray(content.labels) && Array.isArray(content.data))) {\n        throw new Error('Labels and data must be arrays.');\n      } else if (content.labels.length !== content.data.length) {\n        throw new Error('Labels and data length must match.');\n      }\n      content._data_standard_deviation = [];\n      content._data_standard_error = [];\n      for (var i = 0; i < content.data.length; ++i) {\n        var isArr = Array.isArray(content.data[i]);\n        if (this.options.scaleStyle === 'log2') {\n          if (isArr) {\n            for (var i3 = 0; i3 < content.data[i].length; ++i3) content.data[i][i3] = Math.log2(content.data[i][i3]);\n          } else content.data[i] = Math.log2(content.data[i]);\n        }\n        if (isArr) {\n          var mean = Helpers.avg(content.data[i]);\n          var acc = 0;\n          for (var i2 = 0; i2 < content.data[i].length; ++i2) acc += Math.pow(mean - content.data[i][i2], 2);\n          acc = Math.sqrt(acc / (content.data[i].length - 1));\n          content._data_standard_deviation.push(acc);\n          content._data_standard_error.push(acc / Math.sqrt(content.data[i].length));\n        } else {\n          content._data_standard_deviation.push(0);\n          content._data_standard_error.push(0);\n        }\n      }\n      this.content = content;\n      this.redraw();\n    };\n\n    BarChart.prototype.redraw = function() {\n      setTimeout(function() {\n        this._draw();\n      }.bind(this), 0);\n    };\n\n    BarChart.prototype.mousemove = function(x, y) {\n      var res = null;\n      for (var index = 0; index < this.mouseListeners.length; ++index) {\n        if ((res = this.mouseListeners[index](x, y))) break;\n      }\n      if (!res || (typeof res) !== 'object' || !res.hasOwnProperty('index') || !res.hasOwnProperty('drawIndex')) {\n        if (this.currentHint !== null) {\n          this.currentHint = null;\n          this.redraw();\n        }\n        return;\n      }\n      var ch = this.currentHint;\n      if (ch == null || ch.index != res.index || ch.drawIndex != res.drawIndex) {\n        this.currentHint = res;\n        this.redraw();\n      }\n    };\n\n    BarChart.prototype._draw = function() {\n      var labelPositions = { }\n      this.mouseListeners = [];\n      this.fillRegions = [];\n\n      var options = this.options;\n      var ctx = this.ctx, content = this.content;\n      var width = ctx.canvas.width, height = ctx.canvas.height;\n      ctx.clearRect(0, 0, width, height);\n      ctx.translate(-0.5, -0.5);\n      var remainingWidth = width, remainingHeight = height;\n      var index;\n\n      if (options.fillColorBackground != null) {\n        ctx.save();\n        ctx.fillStyle = options.fillColorBackground;\n        ctx.fillRect(0, 0, width, height);\n        ctx.restore();\n      }\n\n      var topYPadding = options.paddingPixelsHorizontal;\n      remainingHeight -= options.paddingPixelsHorizontal;\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      /* Draw title of bar chart */\n      if (content.title != null) {\n        ctx.save();\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTitle, family: options.font });\n        ctx.textAlign = 'center';\n        ctx.fillText(content.title, width / 2, topYPadding + options.fontSizeTitle);\n        ctx.restore();\n        remainingHeight -= options.fontSizeTitle * 1.25;\n        topYPadding += options.fontSizeTitle * 1.25;\n      }\n\n      /* Compute required left padding */\n      var leftXPadding = options.paddingPixelsVertical;\n      remainingWidth  -= options.paddingPixelsVertical;\n\n      var leftXDrawYLabel = null;\n      if (content.yAxis != null) {\n        leftXDrawYLabel = leftXPadding + options.fontSizeAxes * 0.5;\n        remainingWidth -= options.fontSizeAxes * 1.25;\n        leftXPadding += options.fontSizeAxes * 1.25;\n      }\n\n      ctx.save();\n      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });\n      var maxChartValue, minChartValue;\n      if (options.barStyle === 'stacked') {\n        maxChartValue = 0;\n        minChartValue = Infinity;\n        for (var cmIndex = 0; cmIndex < content.data.length; ++cmIndex) {\n          var doB;\n          if (Array.isArray(doB = content.data[cmIndex])) {\n            var tempSum = 0;\n            for (var ii2 = 0; ii2 < doB.length; ++ii2) tempSum += doB[ii2];\n            maxChartValue = Math.max(maxChartValue, tempSum);\n            minChartValue = Math.min(minChartValue, tempSum);\n          } else {\n            maxChartValue = Math.max(maxChartValue, content.data[cmIndex]);\n            minChartValue = Math.min(minChartValue, content.data[cmIndex]);\n          }\n        }\n      } else {\n        maxChartValue = Helpers.upperMax(content.data);\n        minChartValue = Helpers.lowerMin(content.data);\n      }\n      if (options.scaleStyle.indexOf('adaptive') === 0) {\n        if (options.scaleStyle.indexOf(':') !== -1) {\n          var floater = parseFloat(options.scaleStyle.split(/[:]/)[1]);\n          minChartValue *= floater;\n          maxChartValue *= 1 + (1 - floater) / 2.0;\n        }\n      } else minChartValue = 0;\n      if (options.defaultMaxTick > maxChartValue) maxChartValue = options.defaultMaxTick;\n      if (content.bars != null && Array.isArray(content.bars)) {\n        for (index = 0; index < content.bars.length; ++index) {\n          var cbv = content.bars[index].value;\n          if (isNaN(cbv)) continue;\n          maxChartValue = Math.max(maxChartValue, cbv);\n          minChartValue = Math.min(minChartValue, cbv);\n        }\n      }\n      var maxYAxisTickWidth = options.scaleStyle == 'log2' ? Math.ceil(Math.pow(2, maxChartValue)) : (Math.ceil(maxChartValue) + '.00');\n      if (options.tickFormatterMeasure != null) maxYAxisTickWidth = options.tickFormatterMeasure;\n      maxYAxisTickWidth = ctx.measureText(maxYAxisTickWidth).width;\n      maxYAxisTickWidth = Math.ceil(maxYAxisTickWidth) + options.paddingPixelsTicks;\n      remainingWidth -= maxYAxisTickWidth;\n      leftXPadding += maxYAxisTickWidth;\n      ctx.restore();\n\n      var rightXPadding = options.paddingPixelsVertical;\n      remainingWidth -= options.paddingPixelsVertical;\n\n      /* Draw legend */\n      if (content.legend != null && Array.isArray(content.legend)) {\n        ctx.save();\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLegend, family: options.font });\n        var maxLWidth = 0;\n        for (var lIndex = 0; lIndex < content.legend.length; ++lIndex) {\n          maxLWidth = Math.max(maxLWidth, ctx.measureText(content.legend[lIndex].label).width);\n        }\n        maxLWidth = Math.ceil(maxLWidth);\n        maxLWidth += options.pixelsLegendSquare + 8;\n        var legendEntriesPerLine = Math.floor((remainingWidth - options.paddingPixelsHorizontal * 2) / maxLWidth);\n        var lLReqHeight = Math.ceil(content.legend.length / legendEntriesPerLine) * options.fontSizeLegend * 1.5;\n        remainingHeight -= lLReqHeight;\n        bottomYPadding += lLReqHeight;\n\n        ctx.strokeStyle = 'rgb(0, 0, 0)';\n        ctx.fillStyle = options.fillColorLegend;\n        var bSX, bSY;\n        ctx.beginPath();\n        ctx.moveTo(bSX = leftXPadding, bSY = topYPadding + remainingHeight);\n        ctx.lineTo(bSX + remainingWidth, bSY);\n        ctx.lineTo(bSX + remainingWidth, bSY + lLReqHeight);\n        ctx.lineTo(bSX, bSY + lLReqHeight);\n        ctx.lineTo(bSX, bSY);\n        ctx.stroke();\n        ctx.fill();\n\n        for (lIndex = 0; lIndex < content.legend.length; ++lIndex) {\n          var legLine = Math.floor(lIndex / legendEntriesPerLine);\n          var legCol = lIndex % legendEntriesPerLine;\n          ctx.fillStyle = content.legend[lIndex].color;\n          var boxX = bSX + legCol * maxLWidth + 3, boxY = bSY + legLine * options.fontSizeLegend * 1.5 + options.fontSizeLegend * 0.5;\n          ctx.beginPath();\n          ctx.moveTo(boxX, boxY);\n          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY);\n          ctx.lineTo(boxX + options.pixelsLegendSquare, boxY + options.pixelsLegendSquare);\n          ctx.lineTo(boxX, boxY + options.pixelsLegendSquare);\n          ctx.lineTo(boxX, boxY);\n          ctx.fill();\n          ctx.stroke();\n\n          ctx.textAlign = 'left';\n          ctx.fillStyle = 'rgb(0, 0, 0)';\n          ctx.fillText(content.legend[lIndex].label, boxX + 3 + options.pixelsLegendSquare, boxY + options.fontSizeLegend * 0.5);\n        }\n\n        ctx.restore();\n      }\n\n      /* Draw x-axis label of bar chart */\n      var bottomYPadding = options.paddingPixelsHorizontal;\n      remainingHeight -= options.paddingPixelsHorizontal;\n      if (content.xAxis != null) {\n        ctx.save();\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });\n        ctx.fillStyle = 'rgb(0, 0, 0)';\n        ctx.textAlign = 'center';\n        ctx.fillText(content.xAxis, (width - remainingWidth) + remainingWidth / 2, topYPadding + remainingHeight - bottomYPadding);\n        remainingHeight -= options.fontSizeAxes * 1.5;\n        bottomYPadding += options.fontSizeAxes * 1.5;\n        ctx.restore();\n      }\n\n      var widthPerBar = remainingWidth / content.data.length;\n\n      /* Draw x-axis top labels */\n      if (content.topLabels != null) {\n        ctx.save();\n        ctx.textAlign = 'center';\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });\n        remainingHeight -= options.fontSizeLabels * 1.5;\n        topYPadding += options.fontSizeLabels * 1.5;\n        for (index = 0; index < content.topLabels.length; ++index) {\n          ctx.fillText(\n            content.topLabels[index],\n            leftXPadding + index * widthPerBar + widthPerBar / 2,\n            topYPadding - options.fontSizeLabels / 2\n          );\n        }\n        ctx.restore();\n      }\n\n      /* Draw x-axis labels */\n      ctx.save();\n      var reqWidth = 0;\n      if (content.dataTags != null) {\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });\n        var dataTags = content.dataTags;\n        for (index = 0; index < dataTags.length; ++index) {\n          if (Array.isArray(dataTags[index])) {\n            for (var index2 = 0; index2 < dataTags[index].length; ++index2) {\n              reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index][index2]).width + 5));\n            }\n          } else {\n            reqWidth = Math.max(reqWidth, Math.ceil(ctx.measureText(dataTags[index]).width + 5));\n          }\n        }\n      }\n\n      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });\n      var computedBarPadding = Math.floor((widthPerBar * options.paddingPercentBars) / 2);\n      var wwh = widthPerBar - computedBarPadding * 2;\n      if (wwh < reqWidth) {\n        computedBarPadding -= Math.ceil((reqWidth - wwh) / 2);\n        computedBarPadding = Math.max(0, computedBarPadding);\n      } else if (options.maxWidthBars > 0 && wwh > options.maxWidthBars) {\n        computedBarPadding = Math.floor((widthPerBar - options.maxWidthBars) / 2);\n      }\n      var maxTextWidth = 0, maxTextStackSize = 1;\n      for (index = 0; index < content.labels.length; ++index) {\n        var tLabel = content.labels[index];\n        if (Array.isArray(tLabel)) {\n          maxTextStackSize = Math.max(maxTextStackSize, tLabel.length);\n          for (index2 = 0; index2 < tLabel.length; ++index2) {\n            maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel[index2]).width);\n          }\n        } else maxTextWidth = Math.max(maxTextWidth, ctx.measureText(tLabel).width);\n      }\n      var xLabelsRotated = false;\n      if (maxTextWidth > widthPerBar - computedBarPadding) {\n        ctx.textAlign = 'right';\n        ctx.rotate(Math.PI * 1.5);\n        xLabelsRotated = true;\n      } else {\n        ctx.textAlign = 'center';\n      }\n      var lastLabelY = -options.fontSizeLabels;\n      for (index = 0; index < content.labels.length; ++index) {\n        var cLabel = content.labels[index];\n        var x = leftXPadding + index * widthPerBar + widthPerBar / 2, y = topYPadding + remainingHeight - options.fontSizeLabels / 2;\n        if (xLabelsRotated) {\n          y = topYPadding + remainingHeight - maxTextWidth + 5;\n          y = [x, x = -y][0];\n\n          if (y < lastLabelY + options.fontSizeLabels) continue;\n          lastLabelY = y;\n        }\n        var yUp = options.fontSizeLabels * (maxTextStackSize - 1);\n        if (Array.isArray(cLabel)) {\n          if (xLabelsRotated) {\n            yUp = options.fontSizeLabels * (cLabel.length - 1.5);\n            yUp /= 2;\n          }\n          for (index2 = 0; index2 < cLabel.length; ++index2) {\n            ctx.fillText(cLabel[index2], x, y - yUp);\n            yUp -= options.fontSizeLabels;\n          }\n        } else {\n          if (xLabelsRotated) yUp = -options.fontSizeLabels * 0.25;\n          ctx.fillText(cLabel, x, y - yUp);\n        }\n      }\n      if (xLabelsRotated) {\n        remainingHeight -= maxTextWidth + 5;\n        bottomYPadding += maxTextWidth + 5;\n      } else {\n        var remVal = options.fontSizeLabels * maxTextStackSize;\n        remVal += options.fontSizeLabels * 0.5;\n        remainingHeight -= remVal;\n        bottomYPadding += remVal;\n      }\n      ctx.restore();\n\n      /* Draw boundaries */\n      var boundX1 = leftXPadding, boundX2 = leftXPadding + remainingWidth;\n      var boundY1 = topYPadding, boundY2 = topYPadding + remainingHeight;\n\n      for (index = 0; index < content.labels.length; ++index) labelPositions[index] = {\n        xStart: leftXPadding + index * widthPerBar,\n        xEnd: leftXPadding + (1 + index) * widthPerBar,\n        yStart: boundY1, yEnd: boundY2\n      }\n\n      ctx.save();\n      ctx.strokeStyle = 'rgb(0, 0, 0)';\n      ctx.beginPath();\n      if (content.topLabels != null) {\n        ctx.moveTo(boundX2, boundY1);\n        ctx.lineTo(boundX1, boundY1);\n      } else {\n        ctx.moveTo(boundX1, boundY1);\n      }\n      ctx.lineTo(boundX1, boundY2);\n      ctx.lineTo(boundX2, boundY2);\n      if (content.topLabels != null) ctx.lineTo(leftXPadding + remainingWidth, topYPadding);\n      ctx.stroke();\n      ctx.restore();\n\n      /* Draw top label */\n      if (content.topLabel != null) {\n        ctx.save();\n        ctx.textAlign = 'right';\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });\n        ctx.fillText(content.topLabel, leftXPadding - 3, topYPadding - options.fontSizeLabels / 2);\n        ctx.restore();\n      }\n\n      /* Draw y-axis label of bar chart */\n      if (content.yAxis != null) {\n        ctx.save();\n        ctx.rotate(Math.PI * 1.5);\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeAxes, family: options.font });\n        ctx.fillStyle = 'rgb(0, 0, 0)';\n        ctx.textAlign = 'center';\n        ctx.fillText(content.yAxis, -(topYPadding + remainingHeight / 2), leftXDrawYLabel);\n        ctx.restore();\n      }\n\n      /* Draw y-axis labels */\n      ctx.save();\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.20)';\n      ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeTicks, family: options.font });\n      ctx.textAlign = 'right';\n      var tickMeta = Helpers.getLinearTicks(0, maxChartValue, Math.max(2, remainingHeight / (options.fontSizeTicks * (1 + options.paddingPercentTicks))));\n      var alpha = maxChartValue / options.fontSizeTicks;\n      maxChartValue = tickMeta[1];\n      if (maxChartValue > 1) maxChartValue += Math.ceil(alpha);\n      else maxChartValue += alpha;\n      var ticks = [];\n      while (tickMeta[0] <= tickMeta[1]) {\n        ticks.push(tickMeta[0]);\n        tickMeta[0] += tickMeta[2];\n      }\n      for (index = 0; index < ticks.length; ++index) {\n        var tickHeight = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, ticks[index]));\n        if (tickHeight < 0) continue;\n        if (options.scaleStyle == 'log2' && ticks[index] !== 0) ticks[index] = Math.round(Math.pow(2, ticks[index]));\n        else ticks[index] = Math.floor(ticks[index] * 100) / 100;\n        if (options.tickFormatter != null && typeof options.tickFormatter === 'function') {\n          ctx.fillText(options.tickFormatter(ticks[index]).toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);\n        } else {\n          ctx.fillText(ticks[index].toString(), leftXPadding - options.paddingPixelsTicks, topYPadding + remainingHeight - tickHeight);\n        }\n        if (index == 0) continue;\n        ctx.beginPath();\n        ctx.moveTo(leftXPadding, topYPadding + remainingHeight - tickHeight);\n        ctx.lineTo(leftXPadding + remainingWidth, topYPadding + remainingHeight - tickHeight);\n        ctx.stroke();\n      }\n      ctx.restore();\n\n      if (content.bars != null && Array.isArray(content.bars)) {\n        ctx.save();\n        for (index = 0; index < content.bars.length; ++index) {\n          var cBar = content.bars[index];\n          if (cBar.value > maxChartValue) continue;\n          var renderBarY = topYPadding + remainingHeight - Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, cBar.value));\n          ctx.strokeStyle = cBar.style;\n          ctx.fillStyle = cBar.style;\n          ctx.beginPath();\n          ctx.moveTo(boundX1, renderBarY);\n          ctx.lineTo(boundX2, renderBarY);\n          ctx.stroke();\n          ctx.fill();\n        }\n        ctx.restore();\n      }\n\n      /* Draw bars */\n      ctx.save();\n      var lastData = null;\n      for (index = 0; index < content.data.length; ++index) {\n        var fillColorForIndex = null;\n        var strokeColorForIndex = null;\n        if (content.fillColor != null) {\n          if (Array.isArray(content.fillColor)) fillColorForIndex = ctx.fillStyle = content.fillColor[index];\n          else ctx.fillStyle = content.fillColor;\n        } else ctx.fillStyle = options.fillColorBars;\n        if (content.strokeColor != null) {\n          if (Array.isArray(content.strokeColor)) strokeColorForIndex = ctx.strokeStyle = content.strokeColor[index];\n          else ctx.strokeStyle = content.strokeColor;\n        } else ctx.strokeStyle = options.strokeColorBars;\n        var v = content.data[index];\n        var vIsArr = Array.isArray(v);\n        var renderStartX = leftXPadding + widthPerBar * index;\n        if (vIsArr && options.barStyle === 'stacked') {\n          var runningValue = 0, lastHeight = 0;\n          for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {\n            if (fillColorForIndex != null && Array.isArray(fillColorForIndex)) {\n              ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;\n            }\n            if (strokeColorForIndex != null && Array.isArray(strokeColorForIndex)) {\n              ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;\n            }\n\n            runningValue += v[drawIndex];\n            var renderBarHeight = Math.floor(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, runningValue));\n            var renderUpToY = topYPadding + remainingHeight - renderBarHeight;\n            if (Math.abs(renderBarHeight - lastHeight) < options.stackedBarPadding + 2) {\n              lastHeight = renderBarHeight;\n              continue;\n            }\n\n            var barPadP = drawIndex > 0 ? options.stackedBarPadding : 0;\n            var tSX, tSY;\n            var tEX, tEY;\n            ctx.beginPath();\n            ctx.moveTo(tSX = renderStartX + computedBarPadding, tSY = topYPadding + remainingHeight - lastHeight - barPadP);\n            ctx.lineTo(renderStartX + computedBarPadding, renderUpToY);\n            ctx.lineTo(tEX = renderStartX + (widthPerBar - 1) - computedBarPadding, tEY = renderUpToY);\n            ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight - lastHeight - barPadP);\n            if (drawIndex > 0) ctx.lineTo(tSX, tSY);\n            ctx.stroke();\n            ctx.fill();\n            var hint;\n            if (content.hints != null && content.hints[index] != null && (hint = content.hints[index][drawIndex]) != null) {\n              this.mouseListeners.push(function(index, drawIndex, hint, sx, sy, ex, ey, x, y) {\n                var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);\n                var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);\n                if (x < minX || x > maxX || y < minY || y > maxY) return null;\n                return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\\n') };\n              }.bind(this, index, drawIndex, hint, tSX, tSY, tEX, tEY));\n            }\n\n            var tagText;\n            if (tSY - renderUpToY > options.fontDataTags * 1.25 && content.dataTags != null && (tagText = content.dataTags[index]) != null && (tagText = tagText[drawIndex]) != null) {\n              var oFS = ctx.fillStyle;\n              ctx.fillStyle = 'rgb(0, 0, 0)';\n              ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontDataTags, family: options.font });\n              ctx.textAlign = 'center';\n              ctx.fillText(tagText, renderStartX + widthPerBar / 2, tSY - options.fontDataTags * 0.25);\n              ctx.fillStyle = oFS;\n            }\n\n            lastHeight = renderBarHeight;\n          }\n\n          if (content.barTooltips != null) {\n            ctx.fillStyle = 'rgb(0, 0, 0)';\n            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });\n            ctx.textAlign = 'center';\n            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY - 3);\n          }\n        } else if (options.barStyle === 'line') {\n          if (vIsArr) {\n            var rbx = renderStartX + widthPerBar / 2;\n\n            var lDu;\n            if (options.fillRegion === 'background') {\n              lDu = lastData;\n              if (Array.isArray(lDu)) lDu = lDu[0];\n              if (lDu != null) {\n                var sFS = ctx.fillStyle\n                ctx.fillStyle = lDu.color\n                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)\n                ctx.fillStyle = sFS\n              }\n            }\n\n            var nLData = [];\n            for (var drawIndex = 0; drawIndex < v.length; ++drawIndex) {\n              var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v[drawIndex]));\n              var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;\n\n              var rby = renderUpToY3;\n              if (lastData != null) {\n                var tLX, tLY;\n                if (Array.isArray(lastData)) {\n                  tLX = (lastData[drawIndex] || { }).x;\n                  tLY = (lastData[drawIndex] || { }).y;\n                } else {\n                  tLX = lastData.x;\n                  tLY = lastData.y;\n                }\n\n                if (tLX && tLY) {\n                  if (Array.isArray(strokeColorForIndex)) {\n                    ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;\n                  } else ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';\n                  ctx.beginPath();\n                  ctx.moveTo(tLX, tLY);\n                  ctx.lineTo(rbx, rby);\n                  ctx.stroke();\n                }\n              }\n\n              if (Array.isArray(fillColorForIndex)) {\n                ctx.fillStyle = fillColorForIndex[drawIndex] || options.fillColorBars;\n              }\n              if (Array.isArray(strokeColorForIndex)) {\n                ctx.strokeStyle = strokeColorForIndex[drawIndex] || options.strokeColorBars;\n              }\n\n              ctx.beginPath();\n              ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);\n              ctx.stroke();\n              ctx.fill();\n\n              nLData[drawIndex] = { x: rbx, y: rby, color: ctx.fillStyle };\n            }\n            lastData = nLData;\n            if (lDu != null && lDu.color != lastData[0].color) this.fillRegions.push({\n              x: lastData[0].x,\n              y: lastData[0].y,\n              prev: lDu.color,\n              next: lastData[0].color\n            })\n\n            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {\n              var ball = content.balls[index]\n              if (ball != null) {\n                ctx.beginPath();\n                ctx.fillStyle = ball.fill;\n                ctx.strokeStyle = ball.stroke;\n                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);\n                ctx.stroke();\n                ctx.fill();\n              }\n            }\n          } else {\n            var renderBarHeight3 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));\n            var renderUpToY3 = topYPadding + remainingHeight - renderBarHeight3;\n\n            var rbx = renderStartX + widthPerBar / 2, rby = renderUpToY3;\n            var lDu;\n            if (options.fillRegion === 'background') {\n              if (lastData != null) {\n                lDu = lastData;\n                if (Array.isArray(lDu)) lDu = lDu[0];\n                var sFS = ctx.fillStyle\n                ctx.fillStyle = lDu.color\n                ctx.fillRect(lDu.x, boundY1, rbx - lDu.x, boundY2 - boundY1)\n                ctx.fillStyle = sFS\n              }\n            }\n            ctx.beginPath();\n            ctx.arc(rbx, rby, options.radiusDot, 0, 2 * Math.PI);\n            ctx.stroke();\n            ctx.fill();\n\n            if (lastData != null) {\n              if (Array.isArray(lastData)) {\n                var tLX, tLY;\n                for (var key in lastData) {\n                  if (!lastData.hasOwnProperty(key)) continue;\n                  tLX = lastData[key].x;\n                  tLY = lastData[key].y;\n                  if (tLX && tLY) {\n                    ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';\n                    ctx.beginPath();\n                    ctx.moveTo(tLX, tLY);\n                    ctx.lineTo(rbx, rby);\n                    ctx.stroke();\n                  }\n                }\n              } else {\n                var tLX = lastData.x, tLY = lastData.y;\n                if (tLX && tLY) {\n                  ctx.strokeStyle = strokeColorForIndex || 'rgb(0, 0, 0)';\n                  ctx.beginPath();\n                  ctx.moveTo(tLX, tLY);\n                  ctx.lineTo(rbx, rby);\n                  ctx.stroke();\n                }\n              }\n            }\n\n            lastData = { x: rbx, y: rby, color: ctx.fillStyle };\n            if (lDu != null && lDu.color != lastData.color) this.fillRegions.push({\n              x: lastData.x,\n              y: lastData.y,\n              prev: lDu.color,\n              next: lastData.color\n            })\n\n            if (content.balls != null && Array.isArray(content.balls) && index < content.balls.length) {\n              var ball = content.balls[index]\n              if (ball != null) {\n                ctx.beginPath();\n                ctx.fillStyle = ball.fill;\n                ctx.strokeStyle = ball.stroke;\n                ctx.arc(rbx, topYPadding + remainingHeight - (remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, minChartValue + ball.value)), ball.radius, 0, 2 * Math.PI);\n                ctx.stroke();\n                ctx.fill();\n              }\n            }\n          }\n\n          var hint;\n          if (content.hints != null && (hint = content.hints[index]) != null) {\n            this.mouseListeners.push(function(index, hint, sx, sy, ex, ey, x, y) {\n              var minX = Math.min(sx, ex), maxX = Math.max(sx, ex);\n              var minY = Math.min(sy, ey), maxY = Math.max(sy, ey);\n              if (x < minX || x > maxX || y < minY || y > maxY) return null;\n              return { index: index, drawIndex: drawIndex, rect: { left: minX, right: maxX, top: minY, bottom: maxY }, text: hint.split('\\n') };\n            }.bind(this, index, hint, rbx - 1, topYPadding, rbx + 1, topYPadding + remainingHeight));\n          }\n        } else {\n          if (vIsArr) v = Helpers.avg(v);\n          var renderBarHeight2 = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, v));\n          var renderUpToY2 = topYPadding + remainingHeight - renderBarHeight2;\n          ctx.beginPath();\n          ctx.moveTo(renderStartX + computedBarPadding, topYPadding + remainingHeight);\n          ctx.lineTo(renderStartX + computedBarPadding, renderUpToY2);\n          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, renderUpToY2);\n          ctx.lineTo(renderStartX + (widthPerBar - 1) - computedBarPadding, topYPadding + remainingHeight);\n          ctx.stroke();\n          ctx.fill();\n\n          if (options.barStyle === 'error') {\n            var val;\n            if ((val = content._data_standard_error[index]) != 0) {\n              var renderBarError = Math.round(remainingHeight * Helpers.getAxisRatio(minChartValue, maxChartValue, val));\n              ctx.beginPath();\n              var wiskerWidth = Math.round((widthPerBar - computedBarPadding * 2) / 8);\n              var x_ = leftXPadding + widthPerBar * index + widthPerBar / 2;\n              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 + renderBarError);\n              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 + renderBarError);\n              ctx.moveTo(x_, renderUpToY2 + renderBarError);\n              ctx.lineTo(x_, renderUpToY2 - renderBarError);\n              ctx.moveTo(x_ - wiskerWidth, renderUpToY2 - renderBarError);\n              ctx.lineTo(x_ + wiskerWidth, renderUpToY2 - renderBarError);\n              ctx.stroke();\n            }\n          }\n\n          if (content.barTooltips != null) {\n            ctx.fillStyle = 'rgb(0, 0, 0)';\n            ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeLabels, family: options.font });\n            ctx.textAlign = 'center';\n            ctx.fillText(content.barTooltips[index] || '', renderStartX + widthPerBar / 2, renderUpToY2 - 3);\n          }\n        }\n      }\n      ctx.restore();\n\n      if (this.currentHint != null) {\n        ctx.save();\n        var hRect = this.currentHint.rect, hints = this.currentHint.text;\n        ctx.fillStyle = 'rgb(0, 0, 0)';\n        ctx.font = Helpers.getFont({ weight: options.fontWeight, size: options.fontSizeHint, family: options.font });\n        ctx.textAlign = 'left';\n        var boxWidth = 0;\n        for (index = 0; index < hints.length; ++index) {\n          boxWidth = Math.max(boxWidth, Math.ceil(ctx.measureText(hints[index]).width));\n        }\n        var boxWidthPadding = 5;\n        var lineHeight = options.fontSizeHint * 1.5;\n        var boxHeight = hints.length * lineHeight;\n        var drawX = hRect.right + 10, drawY = (hRect.top + hRect.bottom) / 2;\n        boxWidth += boxWidthPadding * 2;\n        if (drawX + boxWidth > width) {\n          drawX = hRect.left - boxWidth - 10;\n        }\n        if (drawY - boxHeight / 2 < 0) {\n          drawY = Math.ceil(boxHeight / 2) + 1;\n        } else if (drawY + boxHeight / 2 > height) {\n          drawY = height - boxHeight / 2 - 1;\n        }\n        ctx.clearRect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);\n        ctx.beginPath();\n        ctx.rect(drawX, drawY - boxHeight / 2, boxWidth, boxHeight);\n        ctx.stroke();\n        for (index = 0; index < hints.length; ++index) {\n          ctx.fillText(hints[index], drawX + boxWidthPadding, drawY - boxHeight / 2 + options.fontSizeHint + index * lineHeight);\n        }\n        ctx.restore();\n      }\n\n      ctx.translate(0.5, 0.5);\n\n      this.labelPositions = labelPositions;\n    };\n\n    return BarChart;\n  })();\n\n  if ( true && typeof module.exports !== 'undefined') {\n    module.exports = BarChart;\n  } else {\n    window.BarChart = BarChart;\n  }\n})();\n\n\n//# sourceURL=webpack://neo_api_stocks/./node_modules/chartjs/chart.js?");

/***/ })

}]);